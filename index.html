<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pomodoro</title>

<style>
  :root { color-scheme: dark; }

  html, body {
    margin: 0;
    padding: 0;
    background: transparent !important;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  }

  .wrap {
    width: 100%;
    padding: 10px;
    box-sizing: border-box;
    display: grid;
    place-items: center;
  }

  .card {
    width: min(340px, 100%);
    border-radius: 18px;
    padding: 14px;

    background: rgba(120, 155, 135, 0.22);
    border: 1px solid rgba(160, 200, 180, 0.35);

    backdrop-filter: blur(14px) saturate(120%);
    -webkit-backdrop-filter: blur(14px) saturate(120%);

    box-shadow:
      0 10px 26px rgba(0,0,0,0.18),
      inset 0 1px 0 rgba(255,255,255,0.15);

    container-type: inline-size;
    container-name: pomo;
  }

  .top {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    margin-bottom: 10px;
  }

  .title {
    font-size: 13px;
    font-weight: 750;
    letter-spacing: 0.2px;
    color: rgba(255,255,255,0.92);
    opacity: 0.95;
  }

  .mute {
    border-radius: 999px;
    border: 1px solid rgba(180,220,200,0.35);
    background: rgba(80,120,100,0.25);
    color: rgba(255,255,255,0.92);
    padding: 8px 10px;
    font-size: 12px;
    font-weight: 700;
    cursor: pointer;
    line-height: 1;
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    white-space: nowrap;
  }

  .time {
    text-align: center;
    font-weight: 750;
    letter-spacing: -1px;
    margin: 6px 0 12px;
    font-size: clamp(40px, 18cqi, 58px);
    color: rgba(255,255,255,0.95);
    text-shadow: 0 2px 10px rgba(0,0,0,0.28);
    user-select: none;
  }

  .sub {
    text-align: center;
    font-size: 12px;
    color: rgba(255,255,255,0.78);
    margin-top: -8px;
    margin-bottom: 12px;
  }

  .rows {
    display: grid;
    gap: 10px;
  }

  .row {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 10px;
    align-items: center;

    padding: 10px 10px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.14);
    background: rgba(0,0,0,0.10);
  }

  .row-left {
    display: flex;
    align-items: center;
    gap: 10px;
    min-width: 0;
  }

  .label {
    font-size: 13px;
    font-weight: 700;
    color: rgba(255,255,255,0.9);
    white-space: nowrap;
  }

  .mins {
    font-size: 13px;
    font-weight: 800;
    color: rgba(255,255,255,0.92);
    opacity: 0.95;
    white-space: nowrap;
  }

  .stepper {
    display: inline-flex;
    gap: 6px;
    margin-left: auto;
  }

  button.btn, button.step {
    border-radius: 999px;
    border: 1px solid rgba(180,220,200,0.35);
    background: rgba(80,120,100,0.25);
    color: rgba(255,255,255,0.92);

    padding: 8px 10px;
    font-size: 12px;
    font-weight: 700;
    cursor: pointer;
    line-height: 1;

    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    white-space: nowrap;
  }

  button.step {
    padding: 8px 10px;
    min-width: 34px;
    text-align: center;
  }

  button:active { transform: translateY(1px); }

  .btn {
    min-width: 108px;
    text-align: center;
  }

  /* === small mode (triggered by ?small=1) === */
  body[data-small="1"] .wrap { padding: 6px; }

  body[data-small="1"] .card {
    padding: 10px;
    width: 260px;
  }

  body[data-small="1"] .title { display: none; }
  body[data-small="1"] .sub { display: none; }
  body[data-small="1"] .top { margin-bottom: 6px; }

  body[data-small="1"] .time {
    font-size: 42px;
    margin: 4px 0 8px;
  }

  body[data-small="1"] .rows { gap: 8px; }

  body[data-small="1"] .row {
    padding: 8px;
    grid-template-columns: 1fr;
    gap: 6px;
  }

  body[data-small="1"] .row-left { justify-content: space-between; }

  body[data-small="1"] .btn {
    width: 100%;
    min-width: unset;
    padding: 8px;
    font-size: 12px;
  }

  body[data-small="1"] .step {
    padding: 6px 8px;
    min-width: 30px;
  }

  body[data-small="1"] .mute {
    padding: 6px 8px;
    font-size: 11px;
  }

  /* ultra-narrow embeds: hide labels */
  @container pomo (max-width: 280px) {
    .label { display: none; }
  }
</style>
</head>

<body>
  <div class="wrap">
    <div class="card" role="application" aria-label="Pomodoro timer">
      <div class="top">
        <div class="title">Pomodoro</div>
        <button class="mute" id="muteBtn" aria-pressed="false" title="Toggle bell sound">ðŸ”” On</button>
      </div>

      <div class="time" id="time">25:00</div>
      <div class="sub" id="modeLabel">Ready: focus</div>

      <div class="rows">
        <!-- Focus row -->
        <div class="row">
          <div class="row-left">
            <div class="label">Focus</div>
            <div class="mins"><span id="focusMins">25</span> min</div>

            <div class="stepper" aria-label="Adjust focus minutes">
              <button class="step" id="focusDown" type="button">âˆ’</button>
              <button class="step" id="focusUp" type="button">+</button>
            </div>
          </div>

          <button class="btn" id="focusBtn" type="button">Start focus</button>
        </div>

        <!-- Break row -->
        <div class="row">
          <div class="row-left">
            <div class="label">Break</div>
            <div class="mins"><span id="breakMins">5</span> min</div>

            <div class="stepper" aria-label="Adjust break minutes">
              <button class="step" id="breakDown" type="button">âˆ’</button>
              <button class="step" id="breakUp" type="button">+</button>
            </div>
          </div>

          <button class="btn" id="breakBtn" type="button">Start break</button>
        </div>
      </div>
    </div>
  </div>

<script>
  const qs = new URLSearchParams(location.search);

  // Enable small mode via ?small=1
  if (qs.get("small") === "1") document.body.dataset.small = "1";

  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));

  let focusMinutes = clamp(parseInt(qs.get("minutes") || "25", 10) || 25, 1, 180);
  let breakMinutes = clamp(parseInt(qs.get("break") || "5", 10) || 5, 1, 60);

  // State
  let mode = "focus"; // "focus" | "break"
  let running = false;
  let intervalId = null;

  // Remaining is always derived from endAt when running
  let remaining = focusMinutes * 60;
  let endAt = null;        // timestamp (ms) when current run ends
  let durationSec = 0;     // duration of current run in seconds

  // Bell on by default (sound=0 turns it off)
  let bellOn = (qs.get("sound") === "0") ? false : true;

  // Elements
  const timeEl = document.getElementById("time");
  const modeLabel = document.getElementById("modeLabel");

  const focusMinsEl = document.getElementById("focusMins");
  const breakMinsEl = document.getElementById("breakMins");

  const focusBtn = document.getElementById("focusBtn");
  const breakBtn = document.getElementById("breakBtn");

  const focusDown = document.getElementById("focusDown");
  const focusUp = document.getElementById("focusUp");
  const breakDown = document.getElementById("breakDown");
  const breakUp = document.getElementById("breakUp");

  const muteBtn = document.getElementById("muteBtn");

  const fmt = (sec) => {
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
  };

  // Web Audio bell (2-tone chime)
  let audioCtx = null;
  async function playBell() {
    if (!bellOn) return;
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") await audioCtx.resume();

      const now = audioCtx.currentTime;

      const tone = (freq, t0, dur, peak) => {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "sine";
        o.frequency.value = freq;

        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(peak, t0 + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

        o.connect(g);
        g.connect(audioCtx.destination);

        o.start(t0);
        o.stop(t0 + dur + 0.03);
      };

      tone(880, now, 0.25, 0.04);
      tone(660, now + 0.16, 0.34, 0.035);
    } catch {
      // fail silently
    }
  }

  function computeRemaining() {
    if (!endAt) return remaining;
    const diff = Math.ceil((endAt - Date.now()) / 1000);
    return Math.max(0, diff);
  }

  function render() {
    remaining = computeRemaining();
    timeEl.textContent = fmt(remaining);
    focusMinsEl.textContent = String(focusMinutes);
    breakMinsEl.textContent = String(breakMinutes);
    muteBtn.textContent = bellOn ? "ðŸ”” On" : "ðŸ”• Off";
    muteBtn.setAttribute("aria-pressed", bellOn ? "false" : "true");
  }

  function updateButtons() {
    const focusRunning = running && mode === "focus";
    const breakRunning = running && mode === "break";

    focusBtn.textContent = focusRunning ? "Stop focus" : "Start focus";
    breakBtn.textContent = breakRunning ? "Stop break" : "Start break";

    if (modeLabel) {
      if (!running) {
        if (!modeLabel.textContent.includes("complete")) {
          modeLabel.textContent = `Ready: ${mode}`;
        }
      } else {
        modeLabel.textContent = `Running: ${mode}`;
      }
    }
  }

  function stopTimer() {
    running = false;
    if (intervalId) clearInterval(intervalId);
    intervalId = null;

    // sync remaining before clearing endAt
    remaining = computeRemaining();
    endAt = null;
    durationSec = 0;

    updateButtons();
    render();
  }

  function startMode(nextMode) {
    mode = nextMode;

    durationSec = (mode === "focus" ? focusMinutes : breakMinutes) * 60;
    endAt = Date.now() + durationSec * 1000;

    // restart interval
    if (intervalId) clearInterval(intervalId);
    running = true;

    const tick = async () => {
      remaining = computeRemaining();
      timeEl.textContent = fmt(remaining);

      if (remaining <= 0) {
        running = false;
        clearInterval(intervalId);
        intervalId = null;

        endAt = null;
        durationSec = 0;

        if (modeLabel) modeLabel.textContent = (mode === "focus") ? "Focus complete" : "Break complete";
        updateButtons();

        await playBell();
      }
    };

    // immediate render + start ticking
    render();
    updateButtons();
    tick();

    // tick faster for smoother UI, but accuracy comes from Date.now()
    intervalId = setInterval(tick, 250);
  }

  function toggleCurrent(modeToToggle) {
    if (running && mode === modeToToggle) {
      stopTimer();
      if (modeLabel) modeLabel.textContent = `Paused: ${mode}`;
      return;
    }
    startMode(modeToToggle);
  }

  function adjust(which, delta) {
    if (which === "focus") {
      focusMinutes = clamp(focusMinutes + delta, 1, 180);
      if (!running) {
        mode = "focus";
        remaining = focusMinutes * 60;
      }
    } else {
      breakMinutes = clamp(breakMinutes + delta, 1, 60);
      if (!running) {
        mode = "break";
        remaining = breakMinutes * 60;
      }
    }

    // adjustments reset the timer for simplicity + predictability
    stopTimer();
    if (modeLabel) modeLabel.textContent = `Ready: ${mode}`;
    render();
    updateButtons();
  }

  // Events
  focusBtn.addEventListener("click", () => toggleCurrent("focus"));
  breakBtn.addEventListener("click", () => toggleCurrent("break"));

  focusDown.addEventListener("click", () => adjust("focus", -1));
  focusUp.addEventListener("click", () => adjust("focus", +1));
  breakDown.addEventListener("click", () => adjust("break", -1));
  breakUp.addEventListener("click", () => adjust("break", +1));

  muteBtn.addEventListener("click", async () => {
    bellOn = !bellOn;
    if (bellOn) {
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === "suspended") await audioCtx.resume();
      } catch {}
    }
    render();
  });

  // Init
  mode = "focus";
  remaining = focusMinutes * 60;
  render();
  updateButtons();

  // Keep the display correct when returning to the tab
  document.addEventListener("visibilitychange", () => {
    if (running) render();
  });
</script>
</body>
</html>
